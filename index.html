<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Shorts Combiner — Render Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .portrait-container {
      width: 100%;
      max-width: 360px;
      aspect-ratio: 9 / 16;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border-radius: 1.5rem;
      overflow: hidden;
      position: relative;
      background-color: #000;
    }
    .video-player {
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 0.3s ease-in-out;
    }
    @keyframes pulse {0%,100%{opacity:1;}50%{opacity:0.5;}}
    .rec-pulse {animation: pulse 1s infinite;}
  </style>
</head>

<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4 font-sans">
  <div class="w-full max-w-xl mx-auto">
    <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Shorts Combiner • Render Edition</h1>
    <p class="text-center text-sm text-gray-600 mb-6">Upload multiple short clips, record continuously, and auto-save to Render backend.</p>

    <div class="bg-white p-6 rounded-xl shadow-lg mb-6 flex flex-col space-y-4">
      <label class="block text-sm font-medium text-gray-700">1. Select Short Clips (MP4/WebM)</label>
      <input type="file" id="videoFiles" accept="video/mp4,video/webm" multiple
        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
      <div id="clipList" class="text-sm text-gray-600 space-y-1">No clips loaded.</div>

      <button id="recordBtn" disabled
        class="w-full px-4 py-3 bg-red-500 text-white font-bold rounded-xl shadow-md hover:bg-red-600 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
        2. START COMPILATION RECORDING
      </button>
    </div>

    <div class="flex justify-center mb-6">
      <div id="videoDisplay" class="portrait-container">
        <video id="videoPlayer" class="video-player" muted style="opacity:0;"></video>
        <div id="recordingOverlay"
          class="hidden absolute top-4 right-4 text-white font-bold text-lg bg-red-600 px-3 py-1 rounded-full rec-pulse">
          REC
        </div>
        <div id="statusOverlay"
          class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center text-white text-center p-4 transition-opacity duration-300">
          <p id="status" class="text-xl font-semibold">Load your video clips to begin.</p>
        </div>
      </div>
    </div>

    <div class="flex flex-col sm:flex-row justify-between items-center bg-white p-4 rounded-xl shadow-lg">
      <p id="progressStatus" class="text-gray-700 text-center sm:text-left mb-2 sm:mb-0">Ready.</p>
      <a id="downloadLink" href="#"
        class="hidden px-4 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 z-10">
        Download Final Video
      </a>
    </div>
  </div>

  <script>
    // --- Core Elements ---
    const videoFilesInput = document.getElementById('videoFiles');
    const videoPlayer = document.getElementById('videoPlayer');
    const recordBtn = document.getElementById('recordBtn');
    const clipListEl = document.getElementById('clipList');
    const statusOverlay = document.getElementById('statusOverlay');
    const statusEl = document.getElementById('status');
    const progressStatusEl = document.getElementById('progressStatus');
    const downloadLink = document.getElementById('downloadLink');
    const recordingOverlay = document.getElementById('recordingOverlay');

    let videoQueue = [], currentClipIndex = 0, mediaRecorder = null;
    let recordedChunks = [], totalDuration = 0;
    let recordingInProgress = false, currentBlobUrl = null, recordingStream = null;

    function formatDuration(s) {
      const m = Math.floor(s / 60), sec = Math.floor(s % 60);
      return `${m.toString().padStart(2,'0')}:${sec.toString().padStart(2,'0')}`;
    }

    function finishLoadingQueue() {
      const totalStr = formatDuration(totalDuration);
      clipListEl.insertAdjacentHTML('beforeend',
        `<div class="mt-2 pt-2 border-t font-semibold flex justify-between"><span>Total Clips: ${videoQueue.length}</span><span>Total Duration: ${totalStr}</span></div>`);
      recordBtn.disabled = !videoQueue.length || totalDuration === 0;
      statusEl.textContent = totalDuration ? `Ready to record ${videoQueue.length} clips.` : `Error loading clips.`;
      statusOverlay.style.opacity = '1';
    }

    videoFilesInput.addEventListener('change', e => {
      videoQueue = Array.from(e.target.files);
      currentClipIndex = 0; totalDuration = 0; clipListEl.innerHTML = '';
      if (!videoQueue.length) { clipListEl.textContent = 'No clips loaded.'; recordBtn.disabled = true; return; }
      statusEl.textContent = 'Analyzing clip durations...'; statusOverlay.style.opacity = '1';
      let loadCount = 0;
      videoQueue.forEach((f,i) => {
        const li = document.createElement('div');
        li.id = `clip-${i}`;
        li.className = 'flex justify-between items-center p-2 rounded';
        li.innerHTML = `<span>${i+1}. ${f.name}</span><span class="text-xs font-mono text-gray-400">Loading...</span>`;
        clipListEl.appendChild(li);
        const temp = document.createElement('video'); temp.muted = true;
        temp.onloadedmetadata = () => {
          const dur = temp.duration;
          totalDuration += isFinite(dur) ? dur : 0;
          li.lastChild.textContent = isFinite(dur) ? formatDuration(dur) : 'Unknown';
          if (++loadCount === videoQueue.length) finishLoadingQueue();
        };
        temp.onerror = () => { li.lastChild.textContent = 'Error'; if (++loadCount === videoQueue.length) finishLoadingQueue(); };
        temp.src = URL.createObjectURL(f);
      });
    });

    function playNextClip(initial=false) {
      if (currentClipIndex >= videoQueue.length) { setTimeout(stopRecording, 800); return; }
      videoPlayer.style.opacity = '0';
      const clip = videoQueue[currentClipIndex];
      statusEl.textContent = `Loading Clip ${currentClipIndex+1}...`;
      statusOverlay.style.opacity = '1';
      progressStatusEl.textContent = `Recording | Clip ${currentClipIndex+1}: ${clip.name}`;
      document.querySelectorAll('#clipList > div').forEach(el=>el.classList.remove('bg-indigo-100'));
      const currentEl = document.getElementById(`clip-${currentClipIndex}`);
      if (currentEl) currentEl.classList.add('bg-indigo-100');
      if (currentBlobUrl) { URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
      currentBlobUrl = URL.createObjectURL(clip);
      videoPlayer.src = currentBlobUrl;
      videoPlayer.oncanplaythrough = () => {
        videoPlayer.oncanplaythrough = null;
        if (initial) initRecorder(); else switchStream();
        videoPlayer.play().then(()=>{
          statusOverlay.style.opacity = '0';
          videoPlayer.style.opacity = '1';
        }).catch(()=>videoPlayer.onended());
      };
      currentClipIndex++;
    }

    function initRecorder() {
      recordingStream = videoPlayer.captureStream();
      let opts = { mimeType: 'video/webm; codecs="vp8, opus"' };
      if (!MediaRecorder.isTypeSupported(opts.mimeType)) opts = { mimeType: 'video/webm' };
      mediaRecorder = new MediaRecorder(recordingStream, opts);
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = handleRecordingStop;
      mediaRecorder.start(100);
      recordBtn.textContent = 'STOP RECORDING';
      recordBtn.classList.replace('bg-red-500','bg-gray-500');
      recordingOverlay.classList.remove('hidden');
      downloadLink.classList.add('hidden');
    }

    function switchStream() {
      try {
        const newS = videoPlayer.captureStream();
        recordingStream.getVideoTracks().forEach(t=>recordingStream.removeTrack(t));
        newS.getVideoTracks().forEach(t=>recordingStream.addTrack(t));
      } catch(e){ console.warn('Stream switch failed',e); }
    }

    function stopRecording() {
      if (!mediaRecorder || mediaRecorder.state==='inactive') return;
      try {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = 360; ctx.canvas.height = 640;
        ctx.fillStyle = 'black'; ctx.fillRect(0,0,360,640);
        const blk = ctx.canvas.captureStream(10);
        const track = blk.getVideoTracks()[0];
        recordingStream.addTrack(track);
        setTimeout(()=>{
          if (mediaRecorder.state!=='inactive') mediaRecorder.stop();
          track.stop();
        },300);
      } catch(e){ console.warn('stop fallback',e); mediaRecorder.stop(); }
    }

    function handleRecordingStop() {
      recordingInProgress = false;
      recordBtn.textContent = '2. START COMPILATION RECORDING';
      recordBtn.classList.replace('bg-gray-500','bg-red-500');
      recordingOverlay.classList.add('hidden');
      const blob = new Blob(recordedChunks,{type:'video/webm'});
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = `short_${Date.now()}.webm`;
      downloadLink.classList.remove('hidden');
      statusEl.textContent = 'Recording finished. Uploading to Render...';
      statusOverlay.style.opacity = '1';
      uploadShort(blob);
    }

    recordBtn.onclick = ()=> recordingInProgress ? stopRecording() : startRecording();
    function startRecording() { if (!videoQueue.length) return alert('Load clips first!'); recordedChunks=[]; currentClipIndex=0; recordingInProgress=true; playNextClip(true); }

    // ---------------- Render Backend Integration ----------------
    const BACKEND_URL = "https://shortscombiner.onrender.com/";

    async function uploadShort(blob) {
      try {
        const formData = new FormData();
        formData.append("video", blob, `short_${Date.now()}.webm`);
        const res = await fetch(`${BACKEND_URL}upload`, { method: "POST", body: formData });


        const data = await res.json();
        let shorts = JSON.parse(localStorage.getItem("shorts") || "[]");
        shorts.push(data.filename);
        localStorage.setItem("shorts", JSON.stringify(shorts));
        progressStatusEl.textContent = `✅ Uploaded: ${data.filename}`;
      } catch (e) {
        console.error("Upload failed:", e);
        progressStatusEl.textContent = "❌ Upload failed. Try again.";
      }
    }

    async function mergeAllShorts() {
      const shorts = JSON.parse(localStorage.getItem("shorts") || "[]");
      if (!shorts.length) return alert("No saved shorts yet!");
      progressStatusEl.textContent = "Merging all shorts on Render...";
      try {
        const res = await fetch(`${BACKEND_URL}/merge`, {
          method: "POST",
          headers: {"Content-Type":"application/json"},
          body: JSON.stringify({ files: shorts })
        });
        if (!res.ok) throw new Error("Merge failed");
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url; a.download = `final_${Date.now()}.mp4`; a.click();
        progressStatusEl.textContent = "✅ Merged video downloaded!";
      } catch (err) {
        console.error("Merge error:", err);
        progressStatusEl.textContent = "❌ Merge failed.";
      }
    }

    const mergeBtn = document.createElement("button");
    mergeBtn.textContent = "Merge All Saved Shorts";
    mergeBtn.className = "w-full px-4 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-md hover:bg-indigo-700 mt-4";
    mergeBtn.onclick = mergeAllShorts;
    document.querySelector(".bg-white.p-6").appendChild(mergeBtn);
  </script>
</body>
</html>
