<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Compilation Recorder</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .portrait-container {
      width: 100%;
      max-width: 360px;
      aspect-ratio: 9 / 16;
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      border-radius: 1.5rem;
      overflow: hidden;
      position: relative;
      background-color: #000;
    }
    .video-player {
      width: 100%;
      height: 100%;
      object-fit: contain;
      transition: opacity 0.3s ease-in-out;
    }
    @keyframes pulse {0%,100%{opacity:1;}50%{opacity:0.5;}}
    .rec-pulse {animation: pulse 1s infinite;}
  </style>
</head>

<body class="bg-gray-50 min-h-screen flex items-center justify-center p-4 font-sans">
  <div class="w-full max-w-xl mx-auto">
    <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">Shorts Compilation Tool</h1>
    <p class="text-center text-sm text-gray-600 mb-6">Upload multiple short clips to compile and record into one continuous video.</p>

    <div class="bg-white p-6 rounded-xl shadow-lg mb-6 flex flex-col space-y-4">
      <label class="block text-sm font-medium text-gray-700">1. Select Short Clips (MP4/WebM)</label>
      <input type="file" id="videoFiles" accept="video/mp4,video/webm" multiple
        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
      <div id="clipList" class="text-sm text-gray-600 space-y-1">No clips loaded.</div>

      <button id="recordBtn" disabled
        class="w-full px-4 py-3 bg-red-500 text-white font-bold rounded-xl shadow-md hover:bg-red-600 transition duration-150 disabled:opacity-50 disabled:cursor-not-allowed">
        2. START COMPILATION RECORDING
      </button>
    </div>

    <div class="flex justify-center mb-6">
      <div id="videoDisplay" class="portrait-container">
        <video id="videoPlayer" class="video-player" muted style="opacity:0;"></video>
        <div id="recordingOverlay"
          class="hidden absolute top-4 right-4 text-white font-bold text-lg bg-red-600 px-3 py-1 rounded-full rec-pulse">
          REC
        </div>
        <div id="statusOverlay"
          class="absolute inset-0 bg-black bg-opacity-70 flex items-center justify-center text-white text-center p-4 transition-opacity duration-300">
          <p id="status" class="text-xl font-semibold">Load your video clips to begin.</p>
        </div>
      </div>
    </div>

    <div class="flex flex-col sm:flex-row justify-between items-center bg-white p-4 rounded-xl shadow-lg">
      <p id="progressStatus" class="text-gray-700 text-center sm:text-left mb-2 sm:mb-0">Ready.</p>
      <a id="downloadLink" href="#"
        class="hidden px-4 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 z-10">
        Download Final Video
      </a>
    </div>
  </div>

  <script>
    const videoFilesInput = document.getElementById('videoFiles');
    const videoPlayer = document.getElementById('videoPlayer');
    const recordBtn = document.getElementById('recordBtn');
    const clipListEl = document.getElementById('clipList');
    const statusOverlay = document.getElementById('statusOverlay');
    const statusEl = document.getElementById('status');
    const progressStatusEl = document.getElementById('progressStatus');
    const downloadLink = document.getElementById('downloadLink');
    const recordingOverlay = document.getElementById('recordingOverlay');

    let videoQueue = [];
    let currentClipIndex = 0;
    let mediaRecorder = null;
    let recordedChunks = [];
    let totalDuration = 0;
    let recordingInProgress = false;
    let currentBlobUrl = null;
    let recordingStream = null;

    function formatDuration(seconds) {
      const min = Math.floor(seconds / 60);
      const sec = Math.floor(seconds % 60);
      return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
    }

    function finishLoadingQueue() {
      const totalStr = formatDuration(totalDuration);
      clipListEl.insertAdjacentHTML('beforeend',
        `<div class="mt-2 pt-2 border-t font-semibold flex justify-between"><span>Total Clips: ${videoQueue.length}</span><span>Total Duration: ${totalStr}</span></div>`);
      recordBtn.disabled = videoQueue.length === 0 || totalDuration === 0;
      statusEl.textContent = totalDuration > 0 ? `Ready to record ${videoQueue.length} clips.` : `Error loading clips.`;
      statusOverlay.style.opacity = '1';
    }

    videoFilesInput.addEventListener('change', (e) => {
      videoQueue = Array.from(e.target.files);
      currentClipIndex = 0;
      totalDuration = 0;
      clipListEl.innerHTML = '';

      if (!videoQueue.length) {
        clipListEl.textContent = 'No clips loaded.';
        recordBtn.disabled = true;
        return;
      }

      statusEl.textContent = 'Analyzing clip durations...';
      statusOverlay.style.opacity = '1';

      let loadCount = 0;
      videoQueue.forEach((file, i) => {
        const li = document.createElement('div');
        li.id = `clip-${i}`;
        li.className = 'flex justify-between items-center p-2 rounded';
        li.innerHTML = `<span>${i + 1}. ${file.name}</span><span class="text-xs font-mono duration-info text-gray-400">Loading...</span>`;
        clipListEl.appendChild(li);

        const tempVideo = document.createElement('video');
        tempVideo.muted = true;
        tempVideo.onloadedmetadata = () => {
          const dur = tempVideo.duration;
          if (isFinite(dur)) {
            totalDuration += dur;
            li.querySelector('.duration-info').textContent = formatDuration(dur);
          } else li.querySelector('.duration-info').textContent = 'Unknown';
          if (++loadCount === videoQueue.length) finishLoadingQueue();
        };
        tempVideo.onerror = () => {
          li.querySelector('.duration-info').textContent = 'Error';
          if (++loadCount === videoQueue.length) finishLoadingQueue();
        };
        tempVideo.src = URL.createObjectURL(file);
      });
    });

    function playNextClip(isInitial = false) {
      if (currentClipIndex >= videoQueue.length) {
        setTimeout(() => stopRecording(), 800);
        return;
      }

      videoPlayer.style.opacity = '0';
      const clipFile = videoQueue[currentClipIndex];
      statusEl.textContent = `Loading Clip ${currentClipIndex + 1}...`;
      statusOverlay.style.opacity = '1';
      progressStatusEl.textContent = `Recording | Clip ${currentClipIndex + 1}: ${clipFile.name}`;
      document.querySelectorAll('#clipList > div').forEach(el => el.classList.remove('bg-indigo-100'));
      const currentClipEl = document.getElementById(`clip-${currentClipIndex}`);
      if (currentClipEl) currentClipEl.classList.add('bg-indigo-100');

      if (currentBlobUrl) {
        URL.revokeObjectURL(currentBlobUrl);
        videoPlayer.src = '';
        currentBlobUrl = null;
      }

      currentBlobUrl = URL.createObjectURL(clipFile);
      videoPlayer.src = currentBlobUrl;

      videoPlayer.oncanplaythrough = () => {
        videoPlayer.oncanplaythrough = null;

        if (isInitial) {
          if (!initAndStartRecorder()) {
            recordingInProgress = false;
            return;
          }
        } else if (mediaRecorder && mediaRecorder.state === 'recording') {
          try {
            const newStream = videoPlayer.captureStream();
            if (newStream && recordingStream) {
              recordingStream.getVideoTracks().forEach(t => { try { recordingStream.removeTrack(t); } catch {} });
              newStream.getVideoTracks().forEach(t => { try { recordingStream.addTrack(t); } catch {} });
              console.log("Stream updated for next clip.");
            }
          } catch (err) {
            console.warn("Stream update failed", err);
          }
        }

        videoPlayer.play().then(() => {
          statusEl.textContent = `Playing Clip ${currentClipIndex + 1}`;
          statusOverlay.style.opacity = '0';
          videoPlayer.style.opacity = '1';
          if (mediaRecorder && mediaRecorder.state === 'paused') mediaRecorder.resume();
        }).catch(err => {
          console.error('Play error', err);
          videoPlayer.onended();
        });
      };

      currentClipIndex++;
    }

    videoPlayer.onended = async () => {
      if (!recordingInProgress) return;
      videoPlayer.pause();
      videoPlayer.currentTime = 0;
      videoPlayer.style.opacity = '0';
      progressStatusEl.textContent = `Clip ${currentClipIndex} finished.`;

      if (currentClipIndex >= videoQueue.length) {
        progressStatusEl.textContent = "Finalizing...";
        await new Promise(r => setTimeout(r, 400));
        if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        return;
      }
      setTimeout(() => playNextClip(), 200);
    };

    function initAndStartRecorder() {
      recordingStream = videoPlayer.captureStream();
      let options = { mimeType: 'video/webm; codecs="vp8, opus"' };
      if (!MediaRecorder.isTypeSupported(options.mimeType)) options = { mimeType: 'video/webm' };
      try {
        mediaRecorder = new MediaRecorder(recordingStream, options);
      } catch (err) {
        console.error("Recorder setup failed:", err);
        return false;
      }
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = handleRecordingStop;
      mediaRecorder.start(100);
      recordBtn.textContent = 'STOP RECORDING';
      recordBtn.classList.replace('bg-red-500', 'bg-gray-500');
      recordingOverlay.classList.remove('hidden');
      downloadLink.classList.add('hidden');
      return true;
    }

    function handleRecordingStop() {
      recordingInProgress = false;
      recordBtn.textContent = '2. START COMPILATION RECORDING';
      recordBtn.classList.replace('bg-gray-500', 'bg-red-500');
      recordingOverlay.classList.add('hidden');
      videoPlayer.pause();
      videoPlayer.src = "";
      if (currentBlobUrl) { URL.revokeObjectURL(currentBlobUrl); currentBlobUrl = null; }
      try {
        if (recordingStream) {
          recordingStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
          recordingStream = null;
        }
      } catch {}
      const blob = new Blob(recordedChunks, { type: mediaRecorder && mediaRecorder.mimeType ? mediaRecorder.mimeType : 'video/webm' });
      const url = URL.createObjectURL(blob);
      downloadLink.href = url;
      downloadLink.download = `compilation_${Date.now()}.webm`;
      downloadLink.classList.remove('hidden');
      progressStatusEl.textContent = `✅ Recording complete! File ready for download.`;
      statusEl.textContent = 'Recording finished. Download below.';
      statusOverlay.style.opacity = '1';
      document.querySelectorAll('#clipList > div').forEach(el => el.classList.remove('bg-indigo-100'));
    }

    recordBtn.addEventListener('click', () => {
      if (recordingInProgress) stopRecording(); else startRecording();
    });

    function startRecording() {
      if (!videoQueue.length) {
        statusEl.textContent = "Please load video clips first!";
        statusOverlay.style.opacity = '1';
        return;
      }
      recordedChunks = [];
      currentClipIndex = 0;
      recordingInProgress = true;
      playNextClip(true);
    }

    function stopRecording() {
      if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
      try {
        const ctx = document.createElement('canvas').getContext('2d');
        ctx.canvas.width = videoPlayer.videoWidth || 360;
        ctx.canvas.height = videoPlayer.videoHeight || 640;
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        const blackStream = ctx.canvas.captureStream(10);
        const track = blackStream.getVideoTracks()[0];
        recordingStream.addTrack(track);
        setTimeout(() => {
          if (mediaRecorder.state !== 'inactive') mediaRecorder.stop();
          track.stop();
        }, 300);
      } catch (err) {
        console.warn("Final flush fallback failed:", err);
        mediaRecorder.stop();
      }
    }

    window.onload = () => statusOverlay.style.opacity = '1';

    // ===================== Render Backend Integration =====================
    const BACKEND_URL = "https://shorts-backend.onrender.com"; // <--- replace with your Render app URL

    async function uploadShort(blob) {
      try {
        const formData = new FormData();
        formData.append("video", blob, `short_${Date.now()}.webm`);
        const res = await fetch(`${BACKEND_URL}/upload`, { method: "POST", body: formData });
        const data = await res.json();
        console.log("Uploaded:", data.filename);
        let shorts = JSON.parse(localStorage.getItem("shorts") || "[]");
        shorts.push(data.filename);
        localStorage.setItem("shorts", JSON.stringify(shorts));
      } catch (err) {
        console.error("Upload failed:", err);
      }
    }

    async function mergeAllShorts() {
      const shorts = JSON.parse(localStorage.getItem("shorts") || "[]");
      if (!shorts.length) return alert("No saved shorts yet!");
      progressStatusEl.textContent = "Merging all shorts, please wait...";
      try {
        const res = await fetch(`${BACKEND_URL}/merge`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ files: shorts })
        });
        if (!res.ok) throw new Error("Merge failed");
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `final_compilation_${Date.now()}.mp4`;
        a.click();
        progressStatusEl.textContent = "✅ Merged video downloaded!";
      } catch (err) {
        console.error("Merge error:", err);
        progressStatusEl.textContent = "❌ Merge failed.";
      }
    }

    const mergeBtn = document.createElement("button");
    mergeBtn.textContent = "Merge All Saved Shorts";
    mergeBtn.className = "w-full px-4 py-3 bg-indigo-600 text-white font-bold rounded-xl shadow-md hover:bg-indigo-700 mt-4";
    mergeBtn.onclick = mergeAllShorts;
    document.querySelector(".bg-white.p-6").appendChild(mergeBtn);

    const originalHandleRecordingStop = handleRecordingStop;
    handleRecordingStop = function() {
      originalHandleRecordingStop.apply(this, arguments);
      const blob = new Blob(recordedChunks, { type: mediaRecorder && mediaRecorder.mimeType ? mediaRecorder.mimeType : 'video/webm' });
      uploadShort(blob);
    };
  </script>
</body>
</html>
